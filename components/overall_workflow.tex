\section{Overall Workflow}
\label{ss:sec:overall_workflow}


\input{diagrams/diagram_overall_architecture}

\subsection{Architecture Overview}
We present the overall workflow in \autoref{fig:spoilsport-architecture}.
\spoilsport takes the solidity source code of the target contract and the role/goal specification as input.
In addition, \spoilsport also takes the specification of state characteristics using role/goal semantics for its state initialization stage.

As final output, it delivers goal violating transaction sequences.

The pipeline consists of three processing stages:
\begin{enumerate}
    \item \textit{Static Analysis} extracts function-level summaries to guide the fuzzer.
    \item \textit{State Initialization} finds meaningful starting states using the user-provided state characteristics specification.
    \item \textit{Goal Violation Search} performs goal-directed fuzzing from the starting state to find violating transaction sequences.
\end{enumerate}

\subsection{Static Analysis}
We first generate function-level summaries which capture the following information:
\begin{enumerate}
    \item \textit{Write variables:} State variables which the function modifies.
    \item \textit{Control-flow variables:} State variables which are involved in conditionals and \texttt{require}/\texttt{assert} statements.
    \item \textit{Parameter types:} Type information for function parameters
\end{enumerate}

Additionally, on a contract-level, we save all hardcoded addresses present in the source code.
These are often used to encode privileged addresses such as admin wallets and fee recipients.
These addresses are used as concrete users during fuzzing.

\subsection{Goal-Directed Fuzzing}
We now detail the fuzzing procedure which underlies \textit{State Initialization} and \textit{Goal Violation Search}.
Once state initialization transaction sequence is found, that sequence is applied prior to our search for goal violations.

In \spoilsport, we treat seeds as a mix of transactions with concretized functions, and transactions with unconcretized functions which leave their arguments and caller unspecified.

We direct the fuzzer to satisfy the specified goals during \textit{State Initialization} as these are interpreted as desired state characteristics to search for.
Inversely, we direct the fuzzer to violate the specified goals during the \textit{Goal Violation Search}.
While we use the same seed generation and seed mutation phases across these stages, we use more complex seed scheduling for \textit{State Initialization} as it involves directing the fuzzer with multiple goals.

\smallskip
\noindent
\textbf{Seed generation:}
We parse the goal specification to retrieve relevant state variables.
For instance, for a \maxsupply goal, we retrieve the \texttt{totalSupply} state variable.
We then populate our initial corpus with single unconcretized function calls of functions which modify these relevant state variables, based on our function summaries.
As any goal violations necessarily have to modify relevant state variables, this allows us to initialize our seeds with these functions as their end targets.

\smallskip
\noindent
\textbf{Seed mutation:}
We attempt to execute a seed by sampling its unconcretized function parameters. 
If a seed fails to execute, we extend it by prepending candidate enabling transactions. These candidates are functions which modify the variables which the failing transaction's control-flow depends on.
This uses a similar insight to~\cite{ethploit}, constructing a transaction sequence from back to front.

\smallskip
\noindent
\textbf{Seed scheduling:}
We implement a round-robin approach to rotate between unconcretized function candidates.
In addition, during \textit{Goal Violation Search}, we employ a simple breadth-first search to prioritize shorter transaction sequences.
This is due to us solving for the violation of only a single goal at a time.
However, during \textit{State Initialization}, we augment this breadth-first search by prioritizing the seeds which have solved the most goals.
For instance, a transaction sequence of length five which has solved three goals would get precedence over a transaction sequence of length 4 which has solved two goals.


\subsection{Specification of Roles and Goals}
Rather than traditional bug or vulnerability test oracles which target bugs and vulnerabilities, we use role/goal semantics to specify user perspectives.
This is for two two reasons.
The first is that role/goal attribution localizes the violation to the user rather than a particular part of the program.
The second is that user desires are often naturally expressed as optimization problems or capabilities of calling particular functions, rather than binary properties.
Internally, \spoilsport does convert specified goals into properties which are checked for violation.

We allow for specifications of binary goals (\textit{does something happen?}), optimization goals (\textit{can I increase this value?}) and call capability goals (\textit{I want to be able to call this function}).


\smallskip
\noindent
\textbf{Roles and Goals for Goal Violation Search:}
We keep the roles and goals general enough to reasonably represent ERC-20 users without specifically accounting for heterogenous contract behavior.
This is to demonstrate that no special tailoring is required for this to find useful rug pull mechanics.

There are two roles involved in this analysis.
The first is a generic \holder role, which is defined as any user whose address is a key in the contract's \texttt{balances} variable.
This mapping variable is a frequently implemented pattern which associates user addresses to unsigned integers which track the amount of tokens they own.
However, such mappings default all keys to a value of $0$, making every user trivially a \holder.
The second is the \owner role, defined as the user who deploys the smart contract.
Internally, we develop a domain-specific language for \spoilsport and specify \holder as \texttt{balances[AddressUser] >= 0} and for the \owner as \texttt{AddressUser == AddressDeployer}.
The roles and goals are specified in 42 lines of Python code.

For the \textit{Token Holder} role, we specify the following goals:
\begin{enumerate}
    \item \textit{\rev{\maxowned}}: $\max$ \texttt{balances[AddressUser]}.
        This optimization goal captures the profit-maximizing goal of a user, which is to own as much value (measured in tokens) as possible.
    \item \textit{\rev{\minsupply}}: $\min$ \texttt{totalSupply}.
        This optimization goal is also a profit-maximizing goal, capturing the intuition that a lower token supply increases the value of each individual token due to increased rarity.
    \item \textit{\liquidity}: $s \leadsto\texttt{AddressUser.transfer(balances[AddressUser])}$.
        This call capability goal captures the natural user expectation that they have full control over spending the tokens which they own.
        We define this as a user being able to transfer their full holdings to any other user, at any point from the start of analysis.
\end{enumerate}

Additionally, we exclude goal violations where a user reduces their own holdings (naively violating \maxowned{}), specified through the constraint \texttt{UserCaller != UserAddress}.
This is in keeping the principle behind \liquidity{}, which is that end-users should have control over their funds.
We also filter out \maxowned goal violations which use the \texttt{transferFrom()} function as their terminal function as these violations are generally trivial and consented to.
The \texttt{transferFrom()} function is typically used by a user who has been approved by the \holder to spend their funds.

We specify the following goal for the \textit{Contract Owner} role:
\begin{enumerate}
    \item \textit{\rev{\maxsupply}}: $\max$ \texttt{totalSupply}.
        Similar to \minsupply{}, this optimization goal is also a profit-maximizing goal but from the perspective of the entire project's value rather than a single user's holdings.
        This captures the intuition that creating more tokens will increase the market capitalization of the project (though this relationship is non-linear and subject to market dynamics).
\end{enumerate}



\textbf{State Characteristics for \textit{State Initialization}:}
We specify initial state characteristics which mimic real-world usage of rug pull contracts.
This is done in in 27 lines of Python code.
These capture the following scenario: tokens are disbursed among multiple users, and that at least one of those users is liquid.
As these are characteristics over groups of users, we extend the role/goal semantics by adding quantifiers over goals.
The characteristics are as follows:
\begin{enumerate}
    \item \textit{Disbursal:}
        $\forall u \in \text{\holder}$, \texttt{balances[u] >= 1000}.
        This ensures token disbursal of at least 1000 tokens to each user, creating multiple \holder{}.
    \item \textit{Any Liquidity:}
    $\exists u \in \text{\holder}$ where $s \leadsto\texttt{AddressUser.transfer(balances[u])}$.
        At least one \holder is liquid.
        We note the deliberate choice to not make all users liquid, as many rug pull implementations are designed to disallow non-privileged users from transferring their funds.
\end{enumerate}