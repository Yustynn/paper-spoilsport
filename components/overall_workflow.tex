\section{Overall Workflow}
\label{ss:sec:overall_workflow}

\input{diagrams/diagram_overall_architecture}

\subsection{Architecture Overview}
We present the overall workflow in \autoref{fig:spoilsport-architecture}.
\spoilsport takes the solidity source code of the target contract and the role/goal specification as input.
In addition, \spoilsport also takes the specification of state characteristics using role/goal semantics for its state initialization stage.

As final output, it delivers goal violating transaction sequences.

The pipeline consists of three processing stages:
\begin{enumerate}
    \item \textit{Static Analysis} extracts function-level summaries to guide the fuzzer.
    \item \textit{State Initialization} finds meaningful starting states using the user-provided state characteristics specification.
    \item \textit{Goal Violation Search} performs goal-directed fuzzing from the starting state to find violating transaction sequences.
\end{enumerate}

In the following, we discuss the key components of \spoilsport in detail. 

\subsection{Specification of Roles and Goals}
Rather than traditional bug or vulnerability test oracles which target bugs and vulnerabilities, we use role/goal semantics to specify user perspectives.
The reasons are two-fold. 
The first is that role/goal attribution localizes the violation to the user rather than a particular part of the program.
The second is that user desires are often naturally expressed as optimization problems or capabilities of calling particular functions, rather than binary properties.
Internally, \spoilsport does convert specified goals into properties which are checked for violation.

We allow for specifications of binary goals (\textit{does something happen?}), optimization goals (\textit{can I increase this value?}) and call capability goals (\textit{I want to be able to call this function}).


\smallskip
\noindent
\textbf{Roles and Goals for Goal Violation Search:}
We keep the roles and goals general enough to reasonably represent ERC-20 users without specifically accounting for heterogenous contract behavior.
This is to demonstrate that no special tailoring is required for this to find useful rug pull mechanics.

There are two roles involved in this analysis.
The first is a generic \holder role, which is defined as any user whose address is a key in the contract's \texttt{balances} variable.
This mapping variable is a frequently implemented pattern which associates user addresses to unsigned integers which track the amount of tokens they own.
However, such mappings default all keys to a value of $0$, making every user trivially a \holder.
The second is the \owner role, defined as the user who deploys the smart contract.
Internally, we develop a domain-specific language for \spoilsport and specify \holder as \texttt{balances[AddressUser] >= 0} and for the \owner as \texttt{AddressUser == AddressDeployer}.
The roles and goals are specified in 42 lines of Python code.

For the \textit{Token Holder} role, we specify the following goals:
\begin{enumerate}
    \item \textit{\rev{\maxowned}}: $\max$ \texttt{balances[AddressUser]}.
        This optimization goal captures the profit-maximizing goal of a user, which is to own as much value (measured in tokens) as possible.
    \item \textit{\rev{\minsupply}}: $\min$ \texttt{totalSupply}.
        Like the previous one, this optimization goal is  a profit-maximizing goal, capturing the intuition that a lower token supply increases the value of each individual token due to increased rarity.
    \item \textit{\liquidity}: $s \leadsto\texttt{AddressUser.transfer(balances[AddressUser])}$.
        This call capability goal captures the natural user expectation that they have full control over spending the tokens which they own.
        We define this as a user being able to transfer their full holdings to any other user, at any point from the start of analysis.
\end{enumerate}

Additionally, we exclude goal violations where a user reduces their own holdings (naively violating \maxowned{}), specified through the constraint \texttt{UserCaller != UserAddress}.
This is in keeping the principle behind \liquidity{}, which is that end-users should have control over their funds.
We also filter out \maxowned goal violations which use the \texttt{transferFrom()} function as their terminal function as these violations are generally trivial and consented to.
The \texttt{transferFrom()} function is typically used by a user who has been approved by the \holder to spend their funds.

We specify the following goal for the \textit{Contract Owner} role:
\begin{enumerate}
    \item \textit{\rev{\maxsupply}}: $\max$ \texttt{totalSupply}.
        Similar to \minsupply{}, this optimization goal is also a profit-maximizing goal but from the perspective of the entire project's value rather than a single user's holdings.
        This captures the intuition that creating more tokens will increase the market capitalization of the project (though this relationship is non-linear and subject to market dynamics).
\end{enumerate}



\textbf{State Characteristics for \textit{State Initialization}:}
We specify initial state characteristics which mimic real-world usage of rug pull contracts.
This is done in in 27 lines of Python code.
These capture the following scenario: tokens are disbursed among multiple users, and that at least one of those users is liquid.
As these are characteristics over groups of users, we extend the role/goal semantics by adding quantifiers over goals.
The characteristics are as follows:
\begin{enumerate}
    \item \textit{Disbursal:}
        $\forall u \in \text{\holder}$, \texttt{balances[u] >= 1000}.
        This ensures token disbursal of at least 1000 tokens to each user, creating multiple \holder{}.
    \item \textit{Any Liquidity:}  At least one \holder is liquid. Therefore, 
    $\exists u \in \text{\holder}$ where $s \leadsto\texttt{AddressUser.transfer(balances[u])}$.
       We note the deliberate choice to not make all users liquid, as many rug pull implementations are designed to disallow non-privileged users from transferring their funds.
\end{enumerate}

\subsection{Static Analysis}
We first generate function-level summaries which capture the following information:
\begin{enumerate}
    \item \textit{Write variables:} State variables which the function modifies.
    \item \textit{Control-flow variables:} State variables which are involved in conditionals and \texttt{require}/\texttt{assert} statements.
    \item \textit{Parameter types:} Type information for function parameters
\end{enumerate}

Additionally, on a contract-level, we save all hardcoded addresses present in the source code.
These are often used to encode privileged addresses such as admin wallets and fee recipients.
These addresses are used as concrete users during fuzzing.

\subsection{Goal-Directed Fuzzing}

\begin{algorithm}[!htb]
\caption{Fuzzing loop for \textit{Goal Violation Search}}
\label{ss:code:fuzz}
\KwIn{Static function summaries $\mathit{fn\_summaries}$, target goal $\mathit{goal}$, initialization sequence $\mathit{init\_seq}$}
\KwOut{Set of goal-violating transaction sequences}

$\mathit{testnet} \gets \textsc{InitTestnet}()$\;
$\mathit{queue} \gets$ new Queue()\;
$\mathit{candidates} \gets \textsc{GetFnsWritingToStateVars}(\mathit{fn\_summaries}, \mathit{goal.state\_vars})$\;

\ForEach{$\mathit{candidate} \in \mathit{candidates}$}{
    $\mathit{init\_seed} \gets$ Seed([$\mathit{candidate}$])\;
    $\mathit{queue}.\textsc{Add}(\mathit{init\_seed})$\;
}

$\mathit{solutions\_trie} \gets$ new SolutionTrie()\;

\While{$|\mathit{queue}| > 0$}{
    $\mathit{seed} \gets \mathit{queue}.\textsc{PopNextCandidate}()$\;
    \If{$\mathit{solutions\_trie}.\textsc{OverlapWith}(\mathit{seed})$}{
        \textbf{continue}\;
    }

    $\mathit{is\_success} \gets$ False\;
    $\mathit{solution} \gets$ None\;

    $\mathit{testnet}.\textsc{RunSequence}(\mathit{init\_seq})$\;
    $\mathit{baseline} \gets \textsc{CheckGoal}(\mathit{testnet}, \mathit{goal})$\;

    \ForEach{$\mathit{sequence} \in \textsc{Concretize}(\mathit{seed})$}{
        $\mathit{testnet}.\textsc{RunSequence}(\mathit{sequence})$\;
        $\mathit{is\_success} \gets \textsc{CheckGoalViolation}(\mathit{testnet}, \mathit{goal}, \mathit{baseline})$\;
        \If{$\mathit{is\_success}$}{
            $\mathit{solution} \gets \mathit{sequence}$\;
            \textbf{break}\;
        }
    }

    \eIf{$\mathit{is\_success}$}{
        $\mathit{solutions\_trie}.\textsc{Add}(\mathit{solution})$\;
    }{
        $\mathit{target\_fn} \gets \mathit{seed}.\textsc{GetFirstUnresolvedFn}()$\;
        $\mathit{prepend\_cands} \gets \textsc{GetFnsWritingToCfDeps}(\mathit{fn\_summaries}, \mathit{target\_fn})$\;
        \ForEach{$\mathit{prepend\_cand} \in \mathit{prepend\_cands}$}{
            $\mathit{new\_seed} \gets \mathit{seed}.\textsc{Copy}()$\;
            $\mathit{new\_seed}.\textsc{Prepend}(\mathit{prepend\_cand})$\;
            $\mathit{queue}.\textsc{Add}(\mathit{new\_seed})$\;
        }
    }
}

\Return $\mathit{solutions\_trie.solutions}$\;
\end{algorithm}

We now detail the fuzzing \revs{loops} which underlies \textit{State Initialization} and \textit{Goal Violation Search}.
These loops are heavily similar, with pseudocode of the \textit{Goal Violation Search} loop found in \autoref{ss:code:fuzz}.
Once state initialization transaction sequence is found, it is applied prior to our search for goal violations.

In \spoilsport, we treat seeds as a mix of transactions with concretized functions, and transactions with 
unconcretized functions which leave their arguments and caller unspecified.

We direct the fuzzer to satisfy the specified goals during \textit{State Initialization} as these are interpreted as desired state characteristics to search for.
Inversely, we direct the fuzzer to violate the specified goals during the \textit{Goal Violation Search}.
While we use the same seed generation and seed mutation phases across these stages, we use more complex seed scheduling for \textit{State Initialization} 
as it involves directing the fuzzer with multiple goals.

\smallskip
\noindent
\textbf{Seed generation:}
\revs{This is shown in lines 3-7 of \autoref{ss:code:fuzz}.}
We parse the goal specification to retrieve relevant state variables.
\revs{
    For instance, in searching for a \maxowned goal violation of \textit{MrMr} motivating example, we retrieve the \texttt{balanceOf} state variable.
}
We then populate our initial corpus with single unconcretized function calls of functions which modify these relevant state variables, based on our function summaries.
\revs{
    For \textit{MrMr}, these include \texttt{transfer()}, \texttt{transferFrom()} and \texttt{\_mints()}.
    As any goal violations necessarily have to modify relevant state variables, all possible goal violating seeds must terminate with a call to one of these functions.
}

\smallskip
\noindent
\textbf{Seed mutation:}
This is shown in lines 17-36 of \autoref{ss:code:fuzz}.
We attempt to execute a seed by sampling its unconcretized function parameters. 
\revs{
    If a seed fails to execute, we create a set of new seeds which prepend candidate functions that may make it succeed.
    These candidates are functions which are shown in the function summaries to write to control flow variables of the seed's failing function.
    For instance, if \texttt{transferFrom()} fails and depends on the \texttt{\_allowances}, the \texttt{increaseAllowance()} and \texttt{decreaseAllowance()} functions will be prepended as they write to \texttt{\_allowances}.
}
If a seed fails to execute, we extend it by prepending candidate enabling transactions.
These candidates are functions which modify the variables which the failing transaction's control-flow depends on.
This uses a similar insight to~\cite{ethploit}, constructing a transaction sequence from back to front.

\smallskip
\noindent
\textbf{Seed scheduling:}
This is implicit in line 10 of \autoref{ss:code:fuzz}.
We implement a round-robin approach to rotate between unconcretized function candidates.
In addition, during \textit{Goal Violation Search}, we employ a simple breadth-first search to prioritize shorter transaction sequences.
This is due to us \revs{fuzzing} for the violation of only a single goal at a time.
However, during \textit{State Initialization}, we augment this breadth-first search by prioritizing the seeds which have \revs{satisfied} the most goals.
For instance, a transaction sequence of length five which has \revs{satisfied} three goals would get precedence over a transaction sequence of length 4 which has \revs{satisfied} two goals.


\smallskip
\noindent
\textbf{Relation to Rug Pull Detectors:}
Our task of enriching a dataset of known rug pulls is complementary but distinct from the rug pull detection task of detectors such as Pied Piper~\cite{pied-piper} and TokenAuditor~\cite{tokenauditor_qrs22}.
Instead of identifying rug pulls, we are enriching understanding of already known rug pulls to surface transaction sequence examples of potential abuse and potentially detect unlabelled rug pull features.
Additionally, our approach is methodologically distinct in that we do not pre-specify patterns of rug pull behavior.
Given these task and methodological differences, comparison with existing rug pull detectors is difficult.

